<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heim's Syntrometric Theory & Live2D Agent Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- (CSS Styles remain exactly the same) --- */
        :root{--background-color:#111122;--text-color:#eeeeee;--container-background:#1e1e2a;--container-border-color:#333355;--accent-color:#00aaff;--link-hover-color:#66ccff;--viz-background:#111122;--info-panel-bg:rgba(40, 40, 60, 0.9);--info-panel-text:#eeeeee;--shadow-color:rgba(0, 0, 0, 0.5);--text-muted:#aaaaaa;}body{font-family:'Inter', sans-serif;line-height:1.7;margin:0;overflow-x:hidden;background-color:var(--background-color);color:var(--text-color);font-size:16px;}header{background:linear-gradient(135deg, #1f1f2f 0%, #2c2c3f 100%);color:var(--text-color);padding:2rem 1rem;text-align:center;box-shadow:0 2px 4px var(--shadow-color);}header h1{margin:0 0 0.5rem 0;font-weight:700;font-size:2.2rem;}header p{margin:0;font-size:1.1rem;color:var(--text-muted);}.container{max-width:900px;margin:2rem auto;padding:2rem;background:var(--container-background);border-radius:8px;border:1px solid var(--container-border-color);box-shadow:0 4px 12px var(--shadow-color);}h2{color:var(--accent-color);margin-top:0;margin-bottom:1.5rem;font-weight:600;border-bottom:2px solid var(--accent-color);padding-bottom:0.5rem;}h3{color:var(--accent-color);margin-top:1.5rem;margin-bottom:1rem;font-weight:600;}p{margin:0 0 1rem 0;}a{color:var(--accent-color);text-decoration:none;font-weight:600;transition:color 0.3s ease;}a:hover, a:focus{color:var(--link-hover-color);text-decoration:underline;}ul{list-style:none;padding-left:0;}li{margin-bottom:0.75rem;position:relative;padding-left:1.5rem;}li::before{content:'â†’';position:absolute;left:0;color:var(--accent-color);font-weight:bold;}.quick-links-list li::before{content:'ðŸ”—';}.threejs-container{width:100%;height:650px;margin:2rem 0;background-color:var(--viz-background);position:relative;border-radius:8px;overflow:hidden;border:1px solid var(--container-border-color);box-shadow:inset 0 0 10px var(--shadow-color);}canvas{display:block;}.label{color:#fff;font-family:'Inter', sans-serif;padding:3px 6px;background:rgba(0, 0, 0, 0.7);border-radius:4px;font-size:11px;font-weight:600;pointer-events:none;user-select:none;white-space:nowrap;position:absolute;text-shadow:1px 1px 2px rgba(0,0,0,0.5);transform:translate(-50%, 0);}#info-panel{position:absolute;top:15px;left:15px;background-color:var(--info-panel-bg);color:var(--info-panel-text);padding:12px 18px;border-radius:6px;max-width:300px;font-size:13px;border:1px solid var(--container-border-color);box-shadow:0 2px 10px var(--shadow-color);z-index:10;pointer-events:none;backdrop-filter:blur(3px);transition:opacity 0.2s ease-in-out;opacity:1;}#info-panel:empty{opacity:0;}#info-panel h3{margin:0 0 8px 0;color:var(--accent-color);font-size:15px;font-weight:700;border-bottom:1px solid rgba(255, 255, 255, 0.15);padding-bottom:6px;}#info-panel p{margin:4px 0;line-height:1.5;}#info-panel p b{color:#aaaaff;font-weight:600;margin-right:5px;}#info-panel .links-list{margin-top:8px;padding-top:6px;border-top:1px solid rgba(255, 255, 255, 0.1);font-size:12px;color:#cccccc;}#info-panel .links-list b{color:#aaccaa;}#info-panel .simulated-data{color:#ffcc66;font-style:italic;font-size:12px;}#live2d-offscreen-canvas{position:absolute;top:-9999px;left:-9999px;width:512px;height:512px;opacity:0;pointer-events:none;}
    </style>
    <!-- Import Map: Only Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <header>
        <!-- ... header content ... -->
         <h1>Heim's Syntrometric Theory Visualization & Live2D Agent Demo</h1>
        <p>Explore Burkhard Heim's unified field theory and a conceptual demo of an integrated AI agent with Live2D.</p>
    </header>

    <div class="container">
        <!-- ... about content ... -->
         <h2>About Syntrometric Theory</h2>
         <p>Burkhard Heim's Syntrometric Theory describes reality as a 12-dimensional quantized system, integrating physics and consciousness. Key concepts include the Syntrix, Metrons, Dimensions (R1-R12), Strukturkaskaden, and Telezentrik.</p>
         <h3>Quick Links</h3>
         <ul class="quick-links-list">
             <li><a href="research/syntrometrie_framework.html" title="View 2D Diagram">Syntrometrie Framework Diagram</a></li>
             <li><a href="research/conscious_agent_arch.html" title="View Agent Architecture">Conscious Agent Architecture Diagram</a></li>
             <li><a href="../README.md" title="Go to Main Project Readme">Main Project README</a></li>
             <li><a href="https://heim-theory.com/" target="_blank" title="External Resource (Opens New Tab)">Heim Theory Resources</a></li>
         </ul>
    </div>

    <div class="container">
        <!-- ... 3D model description ... -->
        <h2>Interactive 3D Model & Live2D Agent Demo</h2>
        <p>The visualization shows Syntrometric concepts and integrates a Live2D avatar placeholder. The agent's simulated internal state influences the avatar's parameters and an "Emergence Core". Hover for details. Use mouse/touch to explore.</p>
        <div class="threejs-container">
            <div id="info-panel"></div>
            <canvas id="live2d-offscreen-canvas"></canvas>
        </div>
    </div>


<!-- 1. Load Cubism 4 Core -->
<script src="https://cdn.jsdelivr.net/npm/live2dcubismcore@4.0.0/lib/live2dcubismcore.min.js"></script>

<!-- 2. Load PIXI.js -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.3/dist/pixi.min.js"></script>

<!-- 3. Load pixi-live2d-display (Cubism 4 version) -->
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@5.0.3/dist/index.min.js"></script>

<!-- 4. Remove ALL other Live2D-related scripts -->

<script>
    // Simple PIXI utils patch instead of proxy
    if(window.PIXI && window.EventEmitter3) {
        PIXI.utils = PIXI.utils || {};
        PIXI.utils.EventEmitter = window.EventEmitter3;
    }
    </script>
</script>

    <!-- === START OF MAIN THREE.JS MODULE SCRIPT === -->
    <script type="module">
        import * as THREE from 'three'; // Loaded via importmap
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // PIXI and Live2DModel are now expected to be available globally on window
        console.log("[Debug Module] Accessing window.PIXI:", window.PIXI);
        // Access Live2DModel via potential locations
        const Live2DModel = window.PIXI?.live2d?.Live2DModel || window.Live2DModel;
        console.log("[Debug Module] Attempting to access Live2DModel globally:", Live2DModel);


        // --- Global Variables ---
        let scene, camera, renderer, labelRenderer, controls;
        let raycaster, mouse;
        let infoPanel;
        const nodes = {}; const edges = []; let container; let clock;
        let agentStateMesh, emergenceCoreMesh; let agentStateLabel, emergenceCoreLabel;
        const simulatedEmotions = new THREE.Vector3(0.5, 0.5, 0.5);
        let simulatedPrevEmotions = simulatedEmotions.clone();
        let simulatedIntegration = 0.5; let simulatedReflexivity = 0.5;
        const RHO_THRESHOLD = 0.8; let simulatedThreshold = 0.6; let emergenceActive = false;
        let live2dPlane;
        let interactableObjects = [];

        // --- Shared State Object (Defined globally for simplicity here) ---
        // The second module will populate this.
        window.sharedLive2DState = {
             pixiApp: null,
             live2dModel: null,
             live2dTexture: null
         };

        // --- Concept Data ---
        const conceptData = { /* ... same concept data ... */
            'reflexive_abstraction': { id: 'reflexive_abstraction', name: 'Reflexive Abstraktion', chapter: 1, position: new THREE.Vector3(0, 15, -20), type: 'method', links: ['syntrometry'], description: "Method..." }, 'subjective_aspect': { id: 'subjective_aspect', name: 'Subjective Aspect (S)', chapter: 1, position: new THREE.Vector3(-10, 10, -18), type: 'structure', links: ['pradikatrix', 'dialektik', 'koordination', 'aspektivsystem'], description: "Contextual framework..." }, 'pradikatrix': { id: 'pradikatrix', name: 'PrÃ¤dikatrix (Pm)', chapter: 1, position: new THREE.Vector3(-20, 15, -16), type: 'component', links: [], description: "Schema..." }, 'dialektik': { id: 'dialektik', name: 'Dialektik (Dn)', chapter: 1, position: new THREE.Vector3(-15, 15, -16), type: 'component', links: [], description: "Schema..." }, 'koordination': { id: 'koordination', name: 'Koordination (Kn)', chapter: 1, position: new THREE.Vector3(-10, 15, -16), type: 'component', links: [], description: "Mechanism..." }, 'aspektivsystem': { id: 'aspektivsystem', name: 'Aspektivsystem (P)', chapter: 1, position: new THREE.Vector3(10, 10, -18), type: 'structure', links: ['metropie', 'idee'], description: "Collection..." }, 'metropie': { id: 'metropie', name: 'Metropie (g)', chapter: 1, position: new THREE.Vector3(20, 15, -16), type: 'property', links: [], description: "Metric..." }, 'idee': { id: 'idee', name: 'Idee (Apodiktic Core)', chapter: 1, position: new THREE.Vector3(15, 5, -16), type: 'core', links: [], description: "Invariant..." }, 'syntrometry': { id: 'syntrometry', name: 'Syntrometrie', chapter: 1, position: new THREE.Vector3(0, 0, -18), type: 'framework', links: ['syntrix'], description: "Heim's logic..." }, 'syntrix': { id: 'syntrix', name: 'Syntrix (Ã£|=)', chapter: 2, position: new THREE.Vector3(0, 0, -10), type: 'structure', links: ['metrophor', 'synkolator', 'synkolation_stage', 'korporator'], description: "Formal structure..." }, 'metrophor': { id: 'metrophor', name: 'Metrophor (Ã£)', chapter: 2, position: new THREE.Vector3(-10, 5, -8), type: 'core', links: ['idee'], description: "Invariant core..." }, 'synkolator': { id: 'synkolator', name: 'Synkolator ({)', chapter: 2, position: new THREE.Vector3(0, 5, -8), type: 'operator', links: [], description: "Correlation law..." }, 'synkolation_stage': { id: 'synkolation_stage', name: 'Synkolation Stage (m)', chapter: 2, position: new THREE.Vector3(10, 5, -8), type: 'parameter', links: [], description: "Arity/depth..." }, 'korporator': { id: 'korporator', name: 'Korporator ({})', chapter: 3, position: new THREE.Vector3(0, -5, -5), type: 'operator', links: ['syntrix'], description: "Combining operator..." },
        };

        // --- Main Initialization Function (Sets up Three.js) ---
        function initMain() {
            container = document.querySelector('.threejs-container');
            infoPanel = document.getElementById('info-panel');
            if (!container) { console.error("Container not found"); return; }
            if (infoPanel) infoPanel.innerHTML = ''; else console.warn("Info panel not found.");

            clock = new THREE.Clock();
            const width = container.clientWidth; const height = container.clientHeight;

            // Three.js Setup
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x111122); scene.fog = new THREE.Fog(0x111122, 60, 160);
            camera = new THREE.PerspectiveCamera(65, width / height, 0.1, 1000); camera.position.set(0, 15, 55);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(width, height); renderer.setPixelRatio(window.devicePixelRatio); container.appendChild(renderer.domElement);
            labelRenderer = new CSS2DRenderer(); labelRenderer.setSize(width, height); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.left = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; container.appendChild(labelRenderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 10; controls.maxDistance = 150; controls.target.set(0, 5, -10); controls.update();
            const ambientLight = new THREE.AmbientLight(0x8080a0); scene.add(ambientLight); const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.0); dirLight1.position.set(5, 10, 7).normalize(); scene.add(dirLight1); const dirLight2 = new THREE.DirectionalLight(0xaaaaff, 0.5); dirLight2.position.set(-5, -5, -5).normalize(); scene.add(dirLight2);

            // Create Live2D Plane (placeholder material initially)
            const planeHeight = 10; const planeWidth = planeHeight; // Assume square
            const planeGeo = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x333344, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            live2dPlane = new THREE.Mesh(planeGeo, planeMat);
            live2dPlane.position.set(0, -10, 0);
            live2dPlane.userData = { type: 'live2d_avatar', name: "Live2D Avatar (Loading...)" };
            scene.add(live2dPlane);
            console.log("[Main Mod] Placeholder Three.js plane created.");

            // Create Original Graph & Other Placeholders
            createNodes(); createEdges(); createAgentSimulationPlaceholders();

            // Final Setup
            interactableObjects = Object.values(nodes).map(n => n.object);
            if (agentStateMesh) interactableObjects.push(agentStateMesh);
            if (live2dPlane) interactableObjects.push(live2dPlane);
            if (emergenceCoreMesh) interactableObjects.push(emergenceCoreMesh);

            setupInteraction(); window.addEventListener('resize', onWindowResize, false); animate();
        }

        // --- Functions (createNodes, createEdges, createPlaceholders, labels, interaction, updateInfoPanel, clearHover, updateSimulationStep, animate, resize) ---
        // --- Implementations remain the same ---
        function createNodes() { const baseSize = 1.5; const labelOffsetFactor = 0.6; for (const id in conceptData) { const data = conceptData[id]; let geometry; let material; let currentScale = 1.0; let detail = 16; switch (data.type) { case 'framework': geometry = new THREE.BoxGeometry(baseSize*2.5, baseSize*2.5, baseSize*2.5); material = new THREE.MeshPhongMaterial({ color: 0x66ccff, shininess: 60, transparent: true, opacity: 0.9 }); break; case 'structure': geometry = new THREE.SphereGeometry(baseSize*1.2, detail, Math.floor(detail/2)); material = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 80 }); break; case 'core': geometry = new THREE.SphereGeometry(baseSize*0.9, detail, Math.floor(detail/2)); material = new THREE.MeshPhongMaterial({ color: 0xffff66, shininess: 100 }); break; case 'component': geometry = new THREE.SphereGeometry(baseSize, detail, Math.floor(detail/2)); material = new THREE.MeshPhongMaterial({ color: 0x66ffaa, shininess: 50 }); break; case 'property': geometry = new THREE.SphereGeometry(baseSize*0.8, detail, Math.floor(detail/2)); material = new THREE.MeshPhongMaterial({ color: 0xffaaff, shininess: 40 }); break; case 'parameter': geometry = new THREE.SphereGeometry(baseSize*0.7, detail, Math.floor(detail/2)); material = new THREE.MeshPhongMaterial({ color: 0xaaffff, shininess: 30 }); break; case 'operator': geometry = new THREE.OctahedronGeometry(baseSize*1.1, 0); material = new THREE.MeshPhongMaterial({ color: 0xffaa66, shininess: 70 }); break; case 'method': geometry = new THREE.CylinderGeometry(baseSize*0.6, baseSize*0.6, baseSize*2.0, detail); material = new THREE.MeshPhongMaterial({ color: 0xff66ff, shininess: 60 }); break; default: geometry = new THREE.BoxGeometry(baseSize, baseSize, baseSize); material = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 20 }); } const nodeMesh = new THREE.Mesh(geometry, material); if (data.position instanceof THREE.Vector3) { nodeMesh.position.copy(data.position); } else { nodeMesh.position.set(Math.random()*20-10, Math.random()*20-10, Math.random()*20-10); } nodeMesh.scale.set(currentScale, currentScale, currentScale); nodeMesh.userData = { type: 'concept', data: data }; scene.add(nodeMesh); const labelDiv = document.createElement('div'); labelDiv.className = 'label'; labelDiv.textContent = data.name; const labelObject = new CSS2DObject(labelDiv); geometry.computeBoundingSphere(); const boundingSphere = geometry.boundingSphere; let yOffset = boundingSphere.radius * currentScale + labelOffsetFactor; if (geometry instanceof THREE.CylinderGeometry) yOffset = (geometry.parameters.height/2)*currentScale + labelOffsetFactor + 0.2; else if (geometry instanceof THREE.BoxGeometry) yOffset = (geometry.parameters.height/2)*currentScale + labelOffsetFactor; labelObject.position.set(0, yOffset, 0); nodeMesh.add(labelObject); nodes[id] = { object: nodeMesh, label: labelObject, data: data }; } console.log(`[Main Mod] Created ${Object.keys(nodes).length} concept nodes.`); }
        function createEdges() { const visitedEdges = new Set(); const tubeRadius = 0.08; const tubeDetail = 6; const tubularSegments = 8; const nodeRadiusFactor = 1.05; const material = new THREE.MeshPhongMaterial({ color: 0x777799, transparent: true, opacity: 0.5, shininess: 10 }); function getApproxBoundaryRadius(geometry, scale) { if (!geometry.boundingSphere) geometry.computeBoundingSphere(); return geometry.boundingSphere ? geometry.boundingSphere.radius * scale : 1.0 * scale; } for (const id in nodes) { const sourceNode = nodes[id]; if (!sourceNode || !sourceNode.object) continue; const sourceScale = sourceNode.object.scale.x; const sourceBoundary = getApproxBoundaryRadius(sourceNode.object.geometry, sourceScale); sourceNode.data.links.forEach(targetId => { const targetNode = nodes[targetId]; if (targetNode && targetNode.object) { const edgeKey = `${id}-${targetId}`; const reverseEdgeKey = `${targetId}-${id}`; if (visitedEdges.has(edgeKey) || visitedEdges.has(reverseEdgeKey)) return; visitedEdges.add(edgeKey); const targetScale = targetNode.object.scale.x; const targetBoundary = getApproxBoundaryRadius(targetNode.object.geometry, targetScale); const startPoint = sourceNode.object.position; const endPoint = targetNode.object.position; const direction = new THREE.Vector3().subVectors(endPoint, startPoint); const distance = direction.length(); if (distance < 0.001) return; direction.normalize(); const shortenStart = sourceBoundary * nodeRadiusFactor; const shortenEnd = targetBoundary * nodeRadiusFactor; const minRequiredDistance = shortenStart + shortenEnd + tubeRadius * 2; if (distance <= minRequiredDistance) return; const adjustedStart = startPoint.clone().add(direction.clone().multiplyScalar(shortenStart)); const adjustedEnd = endPoint.clone().sub(direction.clone().multiplyScalar(shortenEnd)); if (adjustedStart.distanceTo(adjustedEnd) < tubeRadius) return; try { const curve = new THREE.LineCurve3(adjustedStart, adjustedEnd); const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, tubeDetail, false); const edge = new THREE.Mesh(tubeGeometry, material.clone()); scene.add(edge); edges.push(edge); } catch (e) { console.error(`Tube geom error "${id}"<->"${targetId}":`, e); } } else { console.warn(`Target node "${targetId}" not found for link from "${id}"`); } }); } console.log(`[Main Mod] Created ${edges.length} edges.`); }
        function createAgentSimulationPlaceholders() { const placeholderY = -15; const agentStateGeo = new THREE.SphereGeometry(2.5, 32, 16); const agentStateMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 60, transparent: true, opacity: 0.8 }); agentStateMesh = new THREE.Mesh(agentStateGeo, agentStateMat); agentStateMesh.position.set(-15, placeholderY, -5); agentStateMesh.userData = { type: 'agent_state', name: "Agent Internal State" }; scene.add(agentStateMesh); agentStateLabel = createPlaceholderLabel("Agent State", agentStateMesh, 3.0); const emergenceGeo = new THREE.IcosahedronGeometry(1.8, 1); const emergenceMat = new THREE.MeshPhongMaterial({ color: 0xffcc00, emissive: 0x000000, shininess: 80, transparent: true, opacity: 0.6 }); emergenceCoreMesh = new THREE.Mesh(emergenceGeo, emergenceMat); emergenceCoreMesh.position.set(15, placeholderY, -5); emergenceCoreMesh.userData = { type: 'emergence_core', name: "Emergence Core (RIH)" }; scene.add(emergenceCoreMesh); emergenceCoreLabel = createPlaceholderLabel("Emergence Core", emergenceCoreMesh, 2.5); console.log("[Main Mod] Created simulation placeholder objects."); }
        function createPlaceholderLabel(text, parentMesh, yOffset) { const labelDiv = document.createElement('div'); labelDiv.className = 'label'; labelDiv.textContent = text; labelDiv.style.fontSize = '13px'; labelDiv.style.fontWeight = 'bold'; const labelObj = new CSS2DObject(labelDiv); labelObj.position.set(0, yOffset, 0); parentMesh.add(labelObj); return labelObj; }
        function setupInteraction() { raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2(); if (container) { container.addEventListener('mousemove', onPointerMove, false); container.addEventListener('touchmove', onPointerMove, { passive: false }); container.addEventListener('touchend', onPointerUp, false); container.addEventListener('mouseleave', onPointerLeave, false); } }
        let lastIntersected = null;
        function onPointerMove(event) { let clientX, clientY; if (event.touches && event.touches.length>0){ clientX=event.touches[0].clientX; clientY=event.touches[0].clientY; event.preventDefault(); } else { clientX=event.clientX; clientY=event.clientY; } updatePointerPosition(clientX, clientY); checkIntersections(); }
        function onPointerUp(event) { if (event.changedTouches) clearHover(); }
        function onPointerLeave(event) { clearHover(); }
        function updatePointerPosition(clientX, clientY) { if (!container) return; const rect = container.getBoundingClientRect(); mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1; }
        function checkIntersections() { if (!camera || !raycaster || interactableObjects.length === 0) return; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(interactableObjects, false); if (intersects.length > 0) { const intersectedObject = intersects[0].object; if (intersectedObject !== lastIntersected) { updateInfoPanel(intersectedObject); lastIntersected = intersectedObject; } } else { clearHover(); } }
        function updateInfoPanel(nodeMesh) { if (!infoPanel) return; const userData = nodeMesh.userData; if (!userData || !userData.type) { infoPanel.innerHTML = ''; return; } let panelHtml = ''; const safeName = (userData.name || 'Unnamed Object').replace(/</g, "<").replace(/>/g, ">"); switch(userData.type) { case 'concept': const data = userData.data; let linksHtml = ''; if (data.links && data.links.length > 0) { const linkedNames = data.links.map(id => conceptData[id]?.name).filter(n=>n).map(n=>n.replace(/</g, "<").replace(/>/g, ">")); if (linkedNames.length > 0) linksHtml = `<div class="links-list"><b>Links To:</b> ${linkedNames.join(', ')}</div>`; } panelHtml = `<h3>${safeName}</h3> ${data.type ? `<p><b>Type:</b> ${data.type}</p>` : ''} ${data.chapter ? `<p><b>Chapter:</b> ${data.chapter}</p>` : ''} ${data.description ? `<p><b>Desc:</b> ${data.description}</p>` : ''} ${linksHtml}`; break; case 'agent_state': const emoStr = `[V: ${simulatedEmotions.x.toFixed(2)}, A: ${simulatedEmotions.y.toFixed(2)}, D: ${simulatedEmotions.z.toFixed(2)}]`; panelHtml = `<h3>${safeName}</h3> <p class="simulated-data">Represents the AI's internal emotional state.</p> <p><b>Simulated Emotions:</b> ${emoStr}</p>`; break; case 'live2d_avatar': panelHtml = `<h3>${safeName}</h3> <p class="simulated-data">Live2D model driven by simulated agent state.</p> <p><b>(Parameters reflect agent's simulated emotion)</b></p>`; break; case 'emergence_core': const rihState = emergenceActive ? 'Met (Glowing)' : 'Not Met'; panelHtml = `<h3>${safeName}</h3> <p class="simulated-data">Represents RIH-based emergence.</p> <p><b>Simulated I:</b> ${simulatedIntegration.toFixed(3)}</p> <p><b>Simulated Rho:</b> ${simulatedReflexivity.toFixed(3)} (Threshold: ${RHO_THRESHOLD.toFixed(2)})</p> <p><b>Simulated Tau(t):</b> ${simulatedThreshold.toFixed(3)}</p> <p><b>Emergence State:</b> ${rihState}</p>`; break; default: panelHtml = `<h3>${safeName}</h3><p>Unknown object type.</p>`; } infoPanel.innerHTML = panelHtml; }
        function clearHover() { if (lastIntersected) lastIntersected = null; if (infoPanel) infoPanel.innerHTML = ''; }
        function updateSimulationStep(deltaTime) { if (agentStateMesh) { agentStateMesh.material.color.setRGB(simulatedEmotions.x, simulatedEmotions.y, simulatedEmotions.z); agentStateMesh.material.opacity = 0.6 + simulatedIntegration * 0.4; } if (emergenceCoreMesh) { if (emergenceActive) { emergenceCoreMesh.material.emissive.setHex(0xffcc00); emergenceCoreMesh.material.opacity = 0.9; emergenceCoreMesh.scale.setScalar(1.0 + Math.sin(clock.getElapsedTime() * 5.0) * 0.1); } else { emergenceCoreMesh.material.emissive.setHex(0x000000); emergenceCoreMesh.material.opacity = 0.6; emergenceCoreMesh.scale.setScalar(1.0); } }
            // Use sharedState.live2dModel here
            const modelToUpdate = window.sharedLive2DState.live2dModel;
            if (modelToUpdate && modelToUpdate.internalModel && modelToUpdate.internalModel.coreModel) {
                const coreModel = modelToUpdate.internalModel.coreModel;
                const targetAngleX = (simulatedEmotions.x - 0.5) * 60; const targetEyeOpen = simulatedEmotions.y; const targetBreath = simulatedEmotions.z;
                const smoothing = 1.0 - Math.exp(-deltaTime / 0.1);
                const setParam = (id, targetValue, isAngle = false) => { try { let currentVal = coreModel.getParameterValueById(id); let smoothedVal = currentVal + (targetValue - currentVal) * smoothing; if (id.includes('Eye') || id.includes('Breath')) smoothedVal = Math.max(0, Math.min(1, smoothedVal)); if (isAngle) smoothedVal = Math.max(-30, Math.min(30, smoothedVal)); coreModel.setParameterValueById(id, smoothedVal); } catch (e) { } };
                setParam('ParamAngleX', targetAngleX, true); setParam('ParamBodyAngleX', targetAngleX * 0.5, true); setParam('ParamEyeLOpen', targetEyeOpen); setParam('ParamEyeROpen', targetEyeOpen); setParam('ParamBreath', targetBreath); setParam('ParamMouthOpenY', Math.abs(simulatedEmotions.x - 0.5) * 0.5);
            }
            simulatedPrevEmotions.copy(simulatedEmotions); const decay = 0.995; const noiseScale = 0.05; simulatedEmotions.x = (simulatedEmotions.x - 0.5) * decay + 0.5 + (Math.random() - 0.5) * noiseScale; simulatedEmotions.y = (simulatedEmotions.y - 0.5) * decay + 0.5 + (Math.random() - 0.5) * noiseScale; simulatedEmotions.z = (simulatedEmotions.z - 0.5) * decay + 0.5 + (Math.random() - 0.5) * noiseScale; simulatedEmotions.clampScalar(0.0, 1.0); simulatedIntegration = (simulatedEmotions.x + simulatedEmotions.y + simulatedEmotions.z) / 3.0; const dot = simulatedEmotions.dot(simulatedPrevEmotions); const lenSq1 = simulatedEmotions.lengthSq(); const lenSq2 = simulatedPrevEmotions.lengthSq(); simulatedReflexivity = (lenSq1 > 1e-6 && lenSq2 > 1e-6) ? dot / Math.sqrt(lenSq1 * lenSq2) : 1.0; const emotionVariance = simulatedEmotions.clone().subScalar(simulatedIntegration).lengthSq() / 3.0; const stabilityProxy = 1.0 - Math.min(1.0, emotionVariance * 5.0); simulatedThreshold = 0.5 + stabilityProxy * 0.2 - simulatedIntegration * 0.1; simulatedThreshold = Math.max(0.1, Math.min(0.9, simulatedThreshold)); emergenceActive = (simulatedIntegration >= simulatedThreshold) && (simulatedReflexivity >= RHO_THRESHOLD);
        }
        function animate() {
            requestAnimationFrame(animate); const deltaTime = clock.getDelta(); updateSimulationStep(deltaTime);
            // Use sharedState here for Pixi App/Texture
            const { pixiApp, live2dModel, live2dTexture } = window.sharedLive2DState; // Use the globally shared state
            if (pixiApp && live2dModel && live2dTexture) {
                if (typeof live2dModel.update === 'function') live2dModel.update(deltaTime);
                pixiApp.renderer.render(pixiApp.stage);
                live2dTexture.needsUpdate = true;
                 // Update the material map if the texture was assigned late
                 if (live2dPlane && live2dPlane.material.map !== live2dTexture) {
                    live2dPlane.material.map = live2dTexture;
                    live2dPlane.material.needsUpdate = true;
                    live2dPlane.userData.name = "Live2D Avatar"; // Update placeholder name
                    console.log("[Main Animate] Live2D texture assigned to plane material.");
                 }
            }
            if (controls && controls.enabled) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera); if (labelRenderer && scene && camera) labelRenderer.render(scene, camera);
        }
        function onWindowResize() { if (!container || !camera || !renderer || !labelRenderer) return; const width = container.clientWidth; const height = container.clientHeight; camera.aspect = width / height; camera.updateProjectionMatrix(); renderer.setSize(width, height); labelRenderer.setSize(width, height); }

        // --- Start Main Three.js Application ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[Main Mod] DOM ready.");
            // Initialize shared state object globally FIRST
            if (!window.sharedLive2DState) window.sharedLive2DState = {};
            console.log("[Main Mod] Initializing Three.js part...");
            try { initMain(); } catch (error) { /* Error handling */ console.error("[Main Mod] Initialization failed:", error); const errContainer = document.querySelector('.threejs-container') || document.body; errContainer.innerHTML = `<div style="color: #ff4444; background-color: #2a1e2a; border: 1px solid #553355; padding: 1rem; border-radius: 6px; text-align: center; font-weight: bold;">Error initializing 3D visualization: ${error.message}<br>Check console for details.</div>`; if (infoPanel) infoPanel.style.display = 'none'; }
        });
    </script>
    <!-- === END OF MAIN JAVASCRIPT MODULE === -->


    <!-- === START OF SEPARATE LIVE2D INIT MODULE === -->
    <script type="module">
        // This module runs AFTER the main module and AFTER the deferred scripts have loaded
        // It accesses the globally set PIXI proxy and Live2DModel class

        import * as THREE from 'three'; // Import THREE again to use CanvasTexture etc.

        // Access the shared state object created in the main module
        const sharedState = window.sharedLive2DState;
        if(!sharedState) console.error("[Live2D Mod] CRITICAL: sharedLive2DState not found on window!");

        async function initLive2D() {
    console.log("[Live2D Mod] Initializing PixiJS App and Live2D Model...");
    const sharedState = window.sharedLive2DState || {};

    const PIXI = window.PIXI;
    if (!PIXI || !PIXI.Application) {
        console.error("[Live2D Mod] CRITICAL: PIXI or PIXI.Application not found!");
        return;
    }

    // Retry loop: try finding Live2DModel up to 5 times, 200ms apart
    let Live2DModel = PIXI?.live2d?.Live2DModel || window.Live2DModel;
    for (let i = 0; i < 5 && (!Live2DModel || typeof Live2DModel.from !== 'function'); i++) {
        console.warn(`[Live2D Mod] Live2DModel not found (attempt ${i + 1}), waiting...`);
        await new Promise(resolve => setTimeout(resolve, 200));
        Live2DModel = PIXI?.live2d?.Live2DModel || window.Live2DModel;
    }

    if (!Live2DModel || typeof Live2DModel.from !== 'function') {
        console.error("[Live2D Mod] âŒ Live2DModel still not available after retries.");
        alert("Failed to load Live2DModel. Check console for details.");
        return;
    }

    console.log("[Live2D Mod] âœ… Live2DModel found:", Live2DModel);

    try {
        const canvas = document.getElementById('live2d-offscreen-canvas');
        if (!canvas) throw new Error("Offscreen canvas not found!");

        const app = new PIXI.Application();
        await app.init({
            view: canvas,
            width: 512,
            height: 512,
            backgroundAlpha: 0,
            autoStart: false,
            preserveDrawingBuffer: true
        });

        console.log("[Live2D Mod] PixiJS application initialized.");
        sharedState.pixiApp = app;

        const modelPath = 'https://raw.githubusercontent.com/Marko0Marky/Live2d-Avatar-Ai/Advanced_VTuber_AI/models/as01.model3.json';
        console.log(`[Live2D Mod] Loading model from ${modelPath}...`);
        const model = await Live2DModel.from(modelPath, {
            autoInteract: false,
            motionPreload: 'NONE'
        });

        model.scale.set(0.15);
        model.x = app.screen.width / 2;
        model.y = app.screen.height / 1.5;a
        model.anchor.set(0.5, 0.5);
        app.stage.addChild(model);

        console.log("[Live2D Mod] Model loaded and added to stage.");
        sharedState.live2dModel = model;

        const texture = new THREE.CanvasTexture(app.view);
        texture.premultiplyAlpha = true;
        sharedState.live2dTexture = texture;

        console.log("[Live2D Mod] Three.js texture created from Pixi canvas.");
    } catch (err) {
        console.error("[Live2D Mod] Initialization failed:", err);
        alert("Live2D init failed: " + err.message);
        sharedState.pixiApp = null;
        sharedState.live2dModel = null;
        sharedState.live2dTexture = null;
    }
}

        // Wait for DOM content AND potentially the main module to be ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[Live2D Mod] DOM ready.");
            // Delay slightly to increase chance the main module has run and deferred scripts loaded
             setTimeout(() => {
                 if (!window.sharedLive2DState) {
                     console.warn("[Live2D Mod] sharedLive2DState not found by Live2D init, creating.");
                     window.sharedLive2DState = {};
                 }
                 initLive2D().catch(console.error);
             }, 300); // Increased delay slightly more to 300ms
        });

    </script>
    <!-- === END OF SEPARATE LIVE2D INIT MODULE === -->

</body>
</html>
